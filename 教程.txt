1. 入门
    1. 安装
    2. 创建模板
    3. 文件夹结构
    4. typeScript
    5. 启动
2. CSS
    1. 全局样式（/app/layout.tsx、import '@/app/ui/global.css';）
    2. Tailwind
    3. css module（import styles from '@/app/ui/home.module.css';） 通过 styles 对象引用样式
    4. clsx（根据条件切换样式类名）
3. 字体和图像
    1. 添加字体（本地加载）
        1. 编辑 /app/ui/fonts.ts

            import { Inter } from 'next/font/google';
 
            export const inter = Inter({ subsets: ['latin'] });

        2. /app/layout.tsx

            import { inter } from '@/app/ui/fonts';

            <body className={`${inter.className}`}>{children}</body>
    2. 添加图像（自适应、懒加载）

        import Image from 'next/image';

        <Image
            src="/hero-desktop.png"
            width={1000}
            height={760}
            className="hidden md:block"
            alt="Screenshots of the dashboard project showing desktop version"
        />
4. 布局和页面
    1. 文件夹路由（一个文件夹是一个路由段，只有 page 文件内的内容才可公开访问。）
    2. 仪表板布局（layout.tsx，导入到此文件的任何组件都将成为布局的一部分。只有页面组件会更新，而布局不会重新渲染。添加到根布局的任何 UI 都将在应用程序的所有页面之间共享）

        export default function Layout({ children }: { children: React.ReactNode }) {
            return (
                <div className="flex h-screen flex-col md:flex-row md:overflow-hidden">
                <div className="w-full flex-none md:w-64">
                    <SideNav />
                </div>
                <div className="flex-grow p-6 md:overflow-y-auto md:p-12">{children}</div>
                </div>
            );
        }
5. 页面间导航
    1. Link组件（使用<a>标签每次页面导航都会刷新整页！自动代码分割和预期，当Link组件出现在浏览器视口中，会进行预加载）

        import Link from 'next/link';

        <Link
            key={link.name}
            href={link.href}
            className="flex h-[48px] grow items-center justify-center gap-2 rounded-md bg-gray-50 p-3 text-sm font-medium hover:bg-sky-100 hover:text-blue-600 md:flex-none md:justify-start md:p-2 md:px-3"
            >
            <LinkIcon className="w-6" />
            <p className="hidden md:block">{link.name}</p>
        </Link>

    2. usePathname（获取当前链接）

        由于 usePathname() 是一个 React hook，你需要将 nav-links.tsx 转换为客户端组件。在文件顶部添加 React 的 "use client" 指令，然后从 next/navigation 导入 usePathname() ：

        import { usePathname } from 'next/navigation';

        export default function NavLinks() {
            const pathname = usePathname();
            // ...
        }
7. 获取数据
    1. 链接数据库
    2. 请求瀑布流
    3. 并发请求（Promise.all()，时间是以最耗时的那个计算）
8. 静态和动态渲染
    1. 静态渲染（加载快、SEO、减少服务器负载）
    2. 动态渲染（实时数据）
9. 流媒体
    流式传输是一种数据传输技术，它允许您将路由分解为更小的“块”。

    Streaming 与 React 的组件模型配合得很好，因为每个组件都可以被视为一个块 。
    
    在 Next.js 中实现流式传输有两种方法：

        1. 在页面级别，使用 loading.tsx 文件（为您创建 <Suspense> ）。
        2. 在组件级别，使用 <Suspense> 实现更精细的控制。

    1. 页面流媒体

        1. 通过添加 loading.tsx 文件实现，子文件夹页面也会受影响

    2. 加载骨架

        加载骨架是 UI 的简化版本。许多网站将其用作占位符（或备用方案），以指示用户内容正在加载。您在 loading.tsx 中添加的任何 UI 都将作为静态文件的一部分嵌入，并首先发送。然后，其余动态内容将从服务器流式传输到客户端。

    路由组允许您将文件组织成逻辑组，而不会影响 URL 路径结构。当您使用括号 () 创建新文件夹时，其名称不会包含在 URL 路径中。因此， /dashboard/(overview)/page.tsx 会变成 /dashboard 。

    3. 组件流媒体

        import { Suspense } from 'react';

        <Suspense fallback={<RevenueChartSkeleton />}>
          <RevenueChart />
        </Suspense>

        RevenueChartSkeleton 为加载骨架，在数据未加载完成前显示。

    4. 分组组件

        创建一个新的 tsx 文件，将需要同时加载的组件放到该组件里面。（容器组件）

        当你希望多个组件同时加载时，可以使用此模式。
10. 部分预渲染

    部分预渲染是 Next.js 14 中引入的一项实验性功能。随着该功能稳定性的提升，本页面内容可能会更新。部分预渲染 (PPR) 仅在 Next.js 金丝雀版本 ( next@canary ) 中可用，而非 Next.js 稳定版。我们目前不建议在生产环境中使用部分预渲染。

    与之相对的是静态渲染和动态渲染。

    1. 启用 PPR，编辑 next.config.ts

        import type { NextConfig } from 'next';
    
        const nextConfig: NextConfig = {
            experimental: {
                ppr: 'incremental'
            }
        };
        
        export default nextConfig;

    2. 仪表板布局（layout.tsx）中配置 experimental_ppr

        export const experimental_ppr = true;

    部分预渲染的优点在于，您无需更改代码即可使用它。只要您使用 Suspense 包装路由的动态部分，Next.js 就会知道路由的哪些部分是静态的，哪些是动态的。
11. 搜索和分页

    通过 url 保存状态。

    useSearchParams：允许您访问当前 URL 的参数。例如，此 URL /dashboard/invoices?page=1&query=pending 的搜索参数将如下所示： {page: '1', query: 'pending'} 。
    usePathname：允许您读取当前 URL 的路径名。例如，对于路由 /dashboard/invoices ， usePathname 将返回 '/dashboard/invoices' 。
    useRouter：以编程方式启用客户端组件内路由之间的导航。

    何时使用 useSearchParams() 钩子与 searchParams 属性？

        一般来说，如果您想从客户端读取参数，请使用 useSearchParams() 钩子，因为这样可以避免返回服务器。

    https://nextjs.org/learn/dashboard-app/adding-search-and-pagination

    1. 去抖动

        去抖动是一种编程实践，它限制函数触发的频率。

        您可以通过几种方式实现去抖动，包括手动创建自己的去抖动函数。为了简单起见，我们将使用一个名为 use-debounce 库。

        pnpm i use-debounce
12. 表单数据
    1. 创建服务器操作

        通过添加 'use server' ，您可以将文件中的所有导出函数标记为服务器操作。

        向 <form> 元素添加 action 属性，并调用 createInvoice 操作。
    
        从 formData 中提取数据，通过 get 方法。

    2. 验证表单数据

        为了方便您使用，我们将使用 Zod ，一个 TypeScript 优先的验证库，可以为您简化此任务。

        import { z } from 'zod';
 
        const FormSchema = z.object({
            id: z.string(),
            customerId: z.string(),
            amount: z.coerce.number(),
            status: z.enum(['pending', 'paid']),
            date: z.string(),
        });
        
        const CreateInvoice = FormSchema.omit({ id: true, date: true });

        const { customerId, amount, status } = CreateInvoice.parse({
            customerId: formData.get('customerId'),
            amount: formData.get('amount'),
            status: formData.get('status'),
        });

    3. 重新验证和重定向

        Next.js 有一个客户端路由器缓存，它会将路由段暂时存储在用户的浏览器中。除了预取功能外，此缓存还能确保用户能够在路由之间快速导航，同时减少对服务器的请求数量。

        由于您正在更新发票路由中显示的数据，因此您需要清除此缓存并触发对服务器的新请求。您可以使用 Next.js 中的 revalidatePath 函数来执行此操作：

    4. 动态路由段

        您可以通过将文件夹名称括在方括号中来创建动态路由段。例如， [id] 、 [post] 或 [slug] 。

        除了 searchParams 之外，页面组件还接受一个名为 params 的 prop，你可以使用它来访问 id 。更新你的 <Page> 组件以接收该 prop：

    5. 将 id 传递给服务器 Action

        export async function updateInvoice(id: string, formData: FormData) {}

        const updateInvoiceWithId = updateInvoice.bind(null, invoice.id);
 
        return <form action={updateInvoiceWithId}>{/* ... */}</form>;
13. 处理错误